from matplotlib import pyplot as plt
import timeit
import numpy as np
import gurobipy as gp
from gurobipy import LinExpr

def makeILPMatrix(numDataPoints, numTags):
    """
    A function that takes the integers for the number of datapoints and tags in the cluster and outputs a matrix
    in ILP format with randomly generated tag values in the B matrix
    :param numDataPoints: int : number of datapoints in the cluster
    :param numTags: int : number of tags for the datapoints in the cluster
    :return: a list in the form of an ILP
    """
    tagMatrix = np.random.randint(low=0, high=2, size=(numDataPoints, numTags))
    firstColumn = np.arange(1,numDataPoints+1)[:,np.newaxis]
    inputFile = np.append(firstColumn, tagMatrix, axis=1).tolist()
    firstRow = [numDataPoints, numTags]
    inputFile.insert(0, firstRow)
    
    return inputFile

def writeToText(ilpMatrix, filepath):
    """
    A function that takes a list of lists and converts to proper string format and writes to a text file
    to match the text files generated by hitting_set_ilp.write_from_sets() method
    :param ilpMatrix: List<List<int>> : a list of lists representing the ILP formulation of the minimum hitting set problem
    with the first integer of the first row representing the number of datapoints in the cluster and the second integer representing
    the number of tags. The following rows will be the boolean tag values for the hitting set problem's B matrix  
    :param filepath: String : a name for a file without a file extension
    :return: void
    """
    output = ""
    # iterate through input file lists
    for i in range(len(ilpMatrix)):
        lastIndex = len(ilpMatrix[i]) - 1 
        # iterate up to index of second to last element
        for j in range(len(ilpMatrix[i]) - 1):
            output = output + str(ilpMatrix[i][j]) + " "
        # tag on last element
        output = output + str(ilpMatrix[i][lastIndex]) + '\n'

    # create/open a file with the specified name
    with open(f"{filepath}.txt", "w") as f:
        # write the output string to that file
        f.write(str(output))


def indexOfMax(L):
    """
    A helper function that takes a list and returns the index of the largest value in the list.
    If the largest value is in the list more than once, the index of the first occurance will be returned. 
    :param L: List<int> : a list of integers
    : return: int : the index of the largest value
    """
    maxValue = -1
    maxIndex = -1
    for z in range(len(L)):
        if L[z] > maxValue:
            maxValue = L[z]
            maxIndex = z
    return maxIndex        



def findDisjunctive(clusterValues, frequencies):
    """
    A helper function that takes a list of integer arrays containing the tags values for the cluster and a dicionary representing 
    the frequencies of each tag within the cluster.
    :param clusterValues: List<np.array<int>> : a list of lists representing the B matrix for ILP formulation of the minimum hitting set problem.  
    :param frequencies: dict<String, int> : a dictionary with keys as Strings representing tags (e.g. "t1") and values as integers representing
    the frequencies of the tags in the cluster.
    :return: List<String> : a list of Strings representing the tags for the disjunctive descriptor of the minimum hitting set
    """
    # while the clusterValues list is not empty, find the most frequently occurring tag value and add it to the hittingset
    # and check which elements in clusterValues have that tag
    # if the most frequently occurring tag is at a given index of clusterValues, remove that list of tags
    hittingSet = []
    frequencyKeys = list(frequencies.keys())
    frequencyValues = list(frequencies.values())
    while len(clusterValues) > 0:
        maxIndex = indexOfMax(frequencyValues)
        mostFrequentTag = frequencyKeys[maxIndex]
        hittingSet.append(mostFrequentTag)
        frequencyValues[maxIndex] = 0

        mostFrequentTagIndex = int(mostFrequentTag[1:]) - 1 
        hasTag = []
        for tagSet in clusterValues:
            if tagSet[mostFrequentTagIndex] == 1:
                 hasTag.append(1)
            else:
                hasTag.append(0)           

        clusterValuesCopy = []
        for j in range(len(hasTag)):
            if hasTag[j] == 0:
                clusterValuesCopy.append(clusterValues[j])
        clusterValues = clusterValuesCopy
    return hittingSet



# General Heuristic Version of the Minimum Desciptors Problem for a Single CLuster
def solveDisjunctive(ilpMatrix):
    """
    A function that takes a list of lists containing the ilp format for the minimum hitting set problem for a single cluster
    and finds the disjunctive form descriptor for the cluster.
    :param ilpMatrix: List<List<int>> : a list of lists containing information about data and tags in tags in the cluster
        Format: each row after first is a data item
        first row: (1) total number of data items (2) Total number of tags
        following rows: B matrix with rows representing datapoints and columns representing tag presences and absences as 1s and 0s 
    :return: List<String> : a list of Strings representing the tags for the disjunctive descriptor of the minimum hitting set
    """
    # while the clusterValues list is not empty, find the most frequently occurring tag value and add it to the hittingset
    # and check which elements in clusterValues have that tag
    # if the most frequently occurring tag is at a given index of clusterValues, remove that list of tags
    numDataItems = ilpMatrix[0][0]
    numTags = ilpMatrix[0][1]

    # prepare tag frequency dicionary
    frequencies = {}

    for i in range(numTags):
        frequencies["t" + str(i+1)] = 0

    # make numpy array with just the boolean tag data matrix 
    B = ilpMatrix[1:]
    B = np.array(B)[0: , 1:]
    
    # populate the list of frequency dictionary
    tag = 0
    while tag < numTags:
        dataItem = 0
        while dataItem < len(B):
            if B[dataItem][tag] == 1:
                frequencies["t" + str(tag+1)] += 1
            dataItem += 1    
        tag += 1

    # remove data items with no tags (a data item with no tags is nonsensical)
    newTagSets = []
    for tagSetIndex in range(len(B)):
        if B[tagSetIndex].tolist().count(1) > 0:
            newTagSets.append(B[tagSetIndex].tolist())

    # every datapoint in this B matrix is now guarenteed to have at least one tag
    B = newTagSets     

    return findDisjunctive(B, frequencies)  

def solveCNF(ilpMatrix):
    """
    A function that takes a list of lists containing the ilp format for the minimum hitting set problem for a single cluster
    and finds the Conjunctive Normal Form (CNF) Descriptor for the cluster.
    :param ilpMatrix: List<List<int>> : a list of lists containing information about data and tags in tags in the cluster
        Format: each row after first is a data item
        first row: (1) total number of data items (2) Total number of tags
        following rows: B matrix with rows representing datapoints and columns representing tag presences and absences as 1s and 0s 
    :return: List<String> : a list of Strings representing the tags for the CNF descriptor of the minimum hitting set

    This approach finds the first clause by making a disjunctive hitting set for the cluster 
    and then finds the second clause by removing all the tags from the first hitting set from the datapoints in
    the dataset and then finds the second clause by obtaining another disjunctive hitting set from the leftover tags
    limitation 1: if a tagset for a datapoint contains only one tags, a CNF descriptor cannot be formed, therefore, we 
    will first remove all data items that only have one tag from the cluster
    limitation 2: if when we remove the tags from the tagsets that are contained in the intitial hitting set, a tagset becomes empty,
    we will remove that datapoint from the cluster.
    """ 
    numDataItems = ilpMatrix[0][0]
    numTags = ilpMatrix[0][1]

    # prepare tag frequency dicionary
    frequencies = {}

    for i in range(numTags):
        frequencies["t" + str(i+1)] = 0

    # make numpy array with just the boolean tag data matrix 
    B = ilpMatrix[1:]
    # a list containing arrays representing tagSets for each datapoint
    B = np.array(B)[0: , 1:]
    
    # populate the list of frequency dictionary
    tag = 0
    while tag < numTags:
        dataItem = 0
        while dataItem < len(B):
            if B[dataItem][tag] == 1:
                frequencies["t" + str(tag+1)] += 1
            dataItem += 1    
        tag += 1
        
    # remove data items with only one tag from the B matrix
    
    newTagSets = []
    for tagSetIndex in range(len(B)):
        if B[tagSetIndex].tolist().count(1) > 1:
            newTagSets.append(B[tagSetIndex])
    B = newTagSets            

    # find the disjunctive hitting set that will be the first clause of the CNF descriptor
    clause1 = findDisjunctive(B, frequencies) 
        
    # iterate through the B matrix and remove all data items that have been "hit" by the clause1 hitting set
    for tagSetIndex in range(len(B)):
        for tagIndex in range(len(clause1)):
            # isolate the number portion of the tag string for each tag and subtract 1 to find its associated index in the tagset
            index = int(clause1[tagIndex][1:])-1
            # if the tagset contains this tag, remove it from the B matrix
            if B[tagSetIndex][index] == 1:
                B[tagSetIndex][index] = 0

    # now to remove all data items which have no tags following this initial removal of clause1 hitting set tags
    newTagSets = []
    for tagSetIndex in range(len(B)):
        # Check to see if tag set empty. If not empty, append to newTagSets 
        for tagIndex in range(len(B[tagSetIndex])):
            if B[tagSetIndex][tagIndex] == 1:
                newTagSets.append(B[tagSetIndex])
                break
    B = newTagSets  
    # now obtain the second clause by finding a hitting set with the remaining tags
            
    # empty tag frequency dictionary for new hitting set once dataitems removed
    for i in range(numTags):
        frequencies["t" + str(i+1)] = 0
            
        
    # populate the list of frequency dictionaries, one for each cluster
    tag = 0
    while tag < numTags:
        dataItem = 0
        while dataItem < len(B):
            if B[dataItem][tag] == 1:
                frequencies["t" + str(tag+1)] += 1
            dataItem += 1    
        tag += 1

    # find the disjunctive hitting set that will be the second clause of the CNF descriptor
    clause2 = findDisjunctive(B, frequencies)
            
    return (clause1, clause2)
    

"""
An exact solver for the hitting set problem.
"""
__author__ = "William Bradford"
__email__ = "wcb8ze@virginia.edu"


def write_from_sets(sets, filepath):
    """
    A function that takes a list of sets and a name and writes the sets to a text file in the form of an ILP
    :param sets: List<List<int>> : a list of sets
    :param filepath: String : a name for a file without a file extension
    :return: void
    """
    # create a universe, include repeated items
    u = []
    for s in sets:
        # add each set to the universe
        u += s
    # make the universe a range between 1 and the highest value in the universe
    u = range(1, max(u)+1)

    # initialize an empty B matrix
    B = [[0 for i in range(len(u))] for i in range(len(sets))]
    # for each set
    for (i, s) in enumerate(sets):
        # for eat item in the set
        for (j, item) in enumerate(s):
            # write the item to the B matrix
            B[i][item - 1] = 1

    # create the first row of the output
    output = f"{len(sets)} {len(u)} \n"
    # for each row in the B matrix
    for (idx, row) in enumerate(B):
        # append the number corresponding to the data item
        output += f"{idx + 1} "
        # for each item in the row
        for item in row:
            # append the item to the string
            output += f"{item} "
        # append a newline character if the current line is not the last
        if idx != len(B) - 1:
            output += "\n"

    # create/open a file with the specified name
    with open(f"{filepath}.txt", "w") as f:
        # write the output string to that file
        f.write(output)


def from_sets(sets):
    """
    A function to calculate the hitting set
    :param sets: List<List<int>> : the sets of the hitting set problem
    :return: List<int> : the minimum tags required to cover the sets
    """
    # create a universe, include repeated items
    u = []
    for s in sets:
        # add each set to the universe
        u += s
    # cast the universe to a set, then cast it back to a list to remove duplicates
    u = range(1, max(u)+1)
    return from_universe_sets(u, sets)


def from_universe_sets(universe, sets):
    """
    Calculate the hitting set problem from a universe and a list of sets
    :param universe: List<int> : the universe containing all tags
    :param sets: List<List<int>> : the sets
    :return: List<int> : the minimum tags required to cover the sets
    """
    # initialize an empty B matrix
    B = [[0 for i in range(len(universe))] for i in range(len(sets))]
    # for each set
    for (i, s) in enumerate(sets):
        # for each item in the set
        for (j, item) in enumerate(s):
            # write the item to the B matrix
            B[i][item-1] = 1

    return hitting_set_ilp(len(sets), len(universe), B)
 

def hitting_set_ilp(ilpMatrix):
    """
    A function that takes in the number of data items, followed by the number of sets,
    followed by the resulting B matrix and returns the solution to the corresponding minimum hitting set problem
    : param ilpMatrix: List<List<int>> : a list of lists containing information about data and tags in tags in the cluster
        Format: each row after first is a data item
        first row: (1) total number of data items (2) Total number of tags
        following rows: B matrix with rows representing datapoints and columns representing tag presences and absences as 1s and 0s 
    :return: List<String> : a list of Strings representing the tags for the disjunctive descriptor of the minimum hitting set
    """

    # extract n, t, and the B matrix from the input matrix
    n = ilpMatrix[0][0]
    t = ilpMatrix[0][1]

    # make numpy array with just the boolean tag data matrix 
    B = ilpMatrix[1:]
    B = np.array(B)[0: , 1:].tolist()


    # remove data items with no tags (a data item with no tags is nonsensical)
    newTagSets = []
    n = 0
    for tagSetIndex in range(len(B)):
        if B[tagSetIndex].count(1) > 0:
            newTagSets.append(B[tagSetIndex])
            # update n value since datapoints are being removed
            n = n + 1

    # every datapoint in this B matrix is now guarenteed to have at least one tag
    B = newTagSets   
    

    # set an empty environment
    with gp.Env(empty=True) as env:
        # set the env output flag to zero to suppress console output
        env.setParam('OutputFlag', 0)
        # start the environment
        env.start()
        # create the model in the console-suppressed environment
        with gp.Model(env=env) as m:
            # create a list of the y_j variables
            y_var = [m.addVar(vtype=gp.GRB.BINARY, name=f"y{i}") for i in range(1, t + 1)]

            # create a list of 1's to set up the LinExpr with
            coef = [1 for j in range(t)]

            # set the model objective to minimize the number of y_j values that are 1
            m.setObjective(LinExpr(coef, y_var), gp.GRB.MINIMIZE)
            # update the model
            m.update()

            # create an empty list of constraints to add
            c = [0 for i in range(n+1)]
            # for each data item
            for i in range(1, n + 1):
                # for each tag
                for j in range(1, t+1):
                    # if the corresponding value of the B matrix is 1
                    if B[i-1][j-1] == 1:
                        # add the variable to the sum at position i
                        c[i] += y_var[j-1]
                # set the constraint that the sum at index i must be >= 1
                m.addLConstr(c[i], ">=", 1)
            # update the model
            m.update()
            # optimize the model
            m.optimize()

            # get the values of variables
            x_values = m.getAttr("X")
            # initialize an empty list 
            desc = []
            # for each variable
            for (i, x) in enumerate(x_values):
                # if the variable is set to 1
                if x == 1:
                    # append it to the descriptor
                    desc.append("t" + str(i+1))
    return desc




def executionTimes(descriptorType, numTests, numD, numT):
    """
    A function that finds the time it takes to solve the minimum hitting set problem with the specified descriptor type 
    for a dataset with the specified number of datapoints, and number of tags with randomly generated tags values.
    The number of tests to be run can also be specified.
    :param descriptorType: String : a String specifiying the type of descriptor to be returned: either, "disjunctive heuristic", "disjunctive exact", or "CNF"
    :param numTests: int : the number of tests to be run per datapoint by the timeit function
    :param numD: int : the number of datapoints in the cluster
    :param numT: int : the number of tags per datapoint
    :return: int : the amount of time it took (in milleseconds) to find the minimum hitting set for the specified descriptor type
    """
    statement = ""
    if descriptorType == "disjunctive heuristic":
        statement = 'hitting_sets_execution_times.solveDisjunctive(inputMatrix)'
    elif descriptorType == "CNF":
        statement = 'hitting_sets_execution_times.solveCNF(inputMatrix)'
    elif descriptorType == "disjunctive exact":
        statement = 'hitting_sets_execution_times.hitting_set_ilp(inputMatrix)'

    # define a sample code segment and find time
    timeTaken = timeit.timeit(stmt=statement, setup='import hitting_sets_execution_times; import numpy as np; inputMatrix = hitting_sets_execution_times.makeILPMatrix(' +str(numD) + ', ' + str(numT) +  ')', number=numTests)
    # return the difference between start and end time in milli. secs and divide by the number of tests run to find the time per test
    return (timeTaken/numTests)*10**3



def plotTimes(descriptorType, numTags, minNumPoints, maxNumPoints, increment, numTests):
    """
    A function that plots the execution times against the number of datapoints for solving the hitting set problem using either the disjunctive heuristic, disjunctive exact, or Conjunctive Normal Form (CNF)
    descriptors.
    :param descriptorType: String : a String specifiying the type of minimum hitting set solver algorithm to be run: either, "disjunctive heuristic", "disjunctive exact", or "CNF"
    :param numTags: int : the number of tags per datapoints for the synthetic datasets to be generated 
    :param minNumPoints: int : the minumum number of datapoints for the sythetic datasets which will be solved according to the specified (descriptorType) hitting set solver
    :param maxNumPoints: int : the maximum number of datapoints for the sythetic datasets which will be solved according to the specified (descriptorType) hitting set solver
    :param increment: int : the increment at which the the execution times will be calculated and plotted for datapoint values between minNumPoints and maxNumPoints 
    :param numTests: int :  the number of tests to be run per datapoint by the timeit function
    :return: none
    """
    numDatapoints = np.arange(minNumPoints, maxNumPoints, increment)
    exec_times = []
    for num in numDatapoints:
        time = executionTimes(descriptorType=descriptorType, numD=num, numT=numTags, numTests=numTests)
        exec_times.append(time)


    plt.plot(numDatapoints, exec_times, "bo")
    plt.title("Algorithm Processing Times")
    plt.xlabel("Number of Datapoints")
    plt.ylabel("Processing Time (ms)")
    plt.show()

def plotAllTimes(numTags, minNumPoints, maxNumPoints, increment, numTests):
    """
    A function that plots the execution times against the number of datapoints for solving the hitting set problem using the disjunctive heuristic, disjunctive exact, and Conjunctive Normal Form (CNF)
    descriptors.
    :param numTags: int : the number of tags per datapoints for the synthetic datasets to be generated 
    :param minNumPoints: int : the minumum number of datapoints for the sythetic datasets which will be solved according to the specified (descriptorType) hitting set solver
    :param maxNumPoints: int : the maximum number of datapoints for the sythetic datasets which will be solved according to the specified (descriptorType) hitting set solver
    :param increment: int : the increment at which the the execution times will be calculated and plotted for datapoint values between minNumPoints and maxNumPoints 
    :param numTests: int :  the number of tests to be run per datapoint by the timeit function
    :return: none
    """
    numDatapoints = np.arange(minNumPoints, maxNumPoints, increment)
    exec_times_dh = []
    exec_times_de = []
    exec_times_cnf = []

    for num in numDatapoints:
        timeDisJuncHeuristic = executionTimes(descriptorType="disjunctive heuristic", numD=num, numT=numTags, numTests=numTests)
        timeDisjuncExact = executionTimes(descriptorType="disjunctive exact", numD=num, numT=numTags, numTests=numTests)
        timeCNF = executionTimes(descriptorType="CNF", numD=num, numT=numTags, numTests=numTests)
        exec_times_dh.append(timeDisJuncHeuristic)
        exec_times_de.append(timeDisjuncExact)
        exec_times_cnf.append(timeCNF)


    fig, ax = plt.subplots(figsize=(10,4))
    ax.plot(numDatapoints, exec_times_dh, ".", numDatapoints, exec_times_de, ".", numDatapoints, exec_times_cnf, ".")
    plt.title("Algorithm Processing Times")
    plt.xlabel("Number of Datapoints")
    plt.ylabel("Processing Time (ms)")
    plt.legend(["Disjunctive Heuristic", "Disjuctive Exact", "CNF"])
    plt.show()


def plotSizes(descriptorType, numTags, minNumPoints, maxNumPoints, increment):
    """
    A function that plots the hitting set size against the number of datapoints for solving the hitting set problem using either the disjunctive heuristic, disjunctive exact, or Conjunctive Normal Form (CNF)
    descriptors.
    :param descriptorType: String : a String specifiying the type of minimum hitting set solver algorithm to be run: either, "disjunctive heuristic", "disjunctive exact", or "CNF"
    :param numTags: int : the number of tags per datapoints for the synthetic datasets to be generated 
    :param minNumPoints: int : the minumum number of datapoints for the sythetic datasets which will be solved according to the specified (descriptorType) hitting set solver
    :param maxNumPoints: int : the maximum number of datapoints for the sythetic datasets which will be solved according to the specified (descriptorType) hitting set solver
    :param increment: int : the increment at which the the size will be calculated and plotted for datapoint values between minNumPoints and maxNumPoints 
    :return: none
    """
    numDatapoints = np.arange(minNumPoints, maxNumPoints, increment)
    sizes = []
    sizesLeft = []
    sizesRight = []
    if descriptorType == "disjunctive heuristic":
        for num in numDatapoints:
            ilpmatrix = makeILPMatrix(numDataPoints=num, numTags=numTags)
            size = len(solveDisjunctive(ilpmatrix))
            sizes.append(size)
        plt.plot(numDatapoints, sizes, "bo")
        plt.title("Disjunctive Heuristic Algorithm Hitting Set Size")
        plt.xlabel("Number of Datapoints")
        plt.ylabel("Hitting Set Size")
        plt.show()
    elif descriptorType == "disjunctive exact":
        for num in numDatapoints:
            ilpmatrix = makeILPMatrix(numDataPoints=num, numTags=numTags)
            size = len(hitting_set_ilp(ilpmatrix))
            sizes.append(size)
        plt.plot(numDatapoints, sizes, "bo")
        plt.title("Disjunctive Exact Algorithm Hitting Set Size")
        plt.xlabel("Number of Datapoints")
        plt.ylabel("Hitting Set Size")
        plt.show()

    elif descriptorType == "CNF":
        for num in numDatapoints:
            ilpmatrix = makeILPMatrix(numDataPoints=num, numTags=numTags)
            sizeleft = len(solveCNF(ilpmatrix)[0])
            sizeRight = len(solveCNF(ilpmatrix)[1])
            sizesLeft.append(sizeleft)
            sizesRight.append(sizeRight)
        fig, ax = plt.subplots(figsize=(10,4))
        ax.plot(numDatapoints, sizesLeft, ".", numDatapoints, sizesRight, ".")
        plt.title("CNF Algorithm Hitting Set Size")
        plt.xlabel("Number of Datapoints")
        plt.ylabel("Hitting Set Size")
        plt.legend(["Left Clause", "Right Clause"])
        plt.show()

def plotAllDisjuncSizes(numTags, minNumPoints, maxNumPoints, increment):
    """
    A function that plots the hitting set size against the number of datapoints for solving the hitting set problem using the disjunctive heuristic, disjunctive exact, and Conjunctive Normal Form (CNF)
    descriptors.
    :param numTags: int : the number of tags per datapoints for the synthetic datasets to be generated 
    :param minNumPoints: int : the minumum number of datapoints for the sythetic datasets which will be solved according to the specified (descriptorType) hitting set solver
    :param maxNumPoints: int : the maximum number of datapoints for the sythetic datasets which will be solved according to the specified (descriptorType) hitting set solver
    :param increment: int : the increment at which the the size will be calculated and plotted for datapoint values between minNumPoints and maxNumPoints 
    :return: none
    """
    numDatapoints = np.arange(minNumPoints, maxNumPoints, increment)
    sizes_dh = []
    sizes_de = []

    for num in numDatapoints:
        ilpmatrix = makeILPMatrix(numDataPoints=num, numTags=numTags)
        size_dh = len(solveDisjunctive(ilpmatrix))
        size_de = len(hitting_set_ilp(ilpmatrix))
        sizes_dh.append(size_dh)
        sizes_de.append(size_de)

    fig, ax = plt.subplots(figsize=(10,4))
    ax.plot(numDatapoints, sizes_dh, ".", numDatapoints, sizes_de, ".")
    plt.title("Algorithm Hitting Set Sizes")
    plt.xlabel("Number of Datapoints")
    plt.ylabel("Hitting Set Size")
    plt.legend(["Disjunctive Heuristic", "Disjuctive Exact"])
    plt.show()


# SAMPLE TIME PLOTS
# below are sample plots generated by runnning the hitting set ilp solver with the three different solver functions for sythetic datasets with 7 tags.
# These plots run the specified solver method numTests times for each dataset with the number of datapoints between minNumPoints and maxNumPoints incrementing by increment
# These synthetic datasets are composed according to the ilp matrix format with the number of datapoints increasing between minNumPoints and maxNumPoints at increments of (increment) and randomly generated tag values (0 or 1).  

# disjunctive approximation solver (using heuristic algorithm) 
#plotTimes(descriptorType="disjunctive heuristic", numTags=7, minNumPoints=10, maxNumPoints=100000, increment=50, numTests=20)

# disjunctive exact solver (using gurobi optimization)
#plotTimes(descriptorType="disjunctive exact", numTags=7, minNumPoints=10, maxNumPoints=100000, increment=50, numTests=20)

# CNF solver (using heuristic heuristic algorithm)
#plotTimes(descriptorType="CNF", numTags=7, minNumPoints=10, maxNumPoints=100000, increment=50, numTests=20)

# plot all three descriptor types on the same graph
#plotAllTimes(numTags=7, minNumPoints=10, maxNumPoints=1000, increment=50, numTests=20)

# SAMPLE SIZE PLOTS
# below are sample plots generated by runnning the hitting set ilp solver with the three different solver functions for sythetic datasets with 7 tags.
# These plots run the specified solver method numTests times for each dataset with the number of datapoints between minNumPoints and maxNumPoints incrementing by increment
# These synthetic datasets are composed according to the ilp matrix format with the number of datapoints increasing between minNumPoints and maxNumPoints at increments of (increment) and randomly generated tag values (0 or 1). 

# disjunctive approximation solver (using heuristic algorithm) 
#plotSizes(descriptorType="disjunctive heuristic", numTags=7, minNumPoints=10, maxNumPoints=100000, increment=50)

# disjunctive exact solver (using gurobi optimization)
#plotSizes(descriptorType="disjunctive exact", numTags=7, minNumPoints=10, maxNumPoints=100000, increment=50)

# CNF solver (using heuristic heuristic algorithm)
#plotSizes(descriptorType="CNF", numTags=7, minNumPoints=10, maxNumPoints=100000, increment=50)

# plot all three descriptor types on the same graph
#plotAllDisjuncSizes(numTags=7, minNumPoints=10, maxNumPoints=100000, increment=50)
